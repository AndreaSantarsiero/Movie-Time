Il protocollo di sincronizzazione è progettato per funzionare esclusivamente tra due utenti connessi che stanno guardando lo stesso contenuto su Netflix, nella stessa pagina di riproduzione. Si assume che siano gli utenti a portarsi manualmente sullo stesso film o sulla stessa puntata; il sistema non sceglie né cambia autonomamente il contenuto, ma si limita a verificare che i due media risultino compatibili. Per farlo, ciascun lato legge la durata locale del video dall’elemento video HTML della pagina e, quando entrambi hanno attivato il sync, confronta il proprio valore con quello ricevuto dal peer. Se la differenza relativa tra le due durate supera una soglia configurabile (ad esempio 1%) il contenuto viene considerato non compatibile, il protocollo non entra nello stato di sincronizzazione attiva e l’interfaccia può comunicare all’utente che non è possibile sincronizzare le riproduzioni.

Internamente il protocollo distingue quattro fasi di stato: la fase disattivata, in cui il sync è spento e non viene scambiato alcun messaggio di coordinamento; la fase di attivazione, in cui almeno uno dei due utenti ha premuto il pulsante di sync e i due client si stanno scambiando informazioni preliminari; la fase sincronizzata, in cui leader e follower sono agganciati e stanno scambiando heartbeat periodici; e infine la fase degradata, in cui il follower non riceve più heartbeat nei tempi previsti e sospende i riallineamenti automatici. All’inizio, quando un utente preme il pulsante di sync, il suo client passa dalla fase disattivata alla fase di attivazione, registra un timestamp di attivazione e invia al peer un messaggio che contiene questo timestamp insieme alla durata locale del media. Finché solo uno dei due ha attivato il sync, o finché un lato non ha ancora ricevuto i dati dall’altro, entrambi rimangono in questa fase intermedia.

Quando entrambi i lati hanno attivato il sync, hanno scambiato timestamp e durata, e il controllo di compatibilità sulla durata è andato a buon fine, il protocollo procede a eleggere un leader e un follower. L’elezione è deterministica e si basa prima di tutto sui timestamp di attivazione: il peer che ha attivato per primo, cioè quello con timestamp più vecchio, assume il ruolo di leader, mentre l’altro assume il ruolo di follower. Non è necessario che gli orologi dei due sistemi siano sincronizzati in assoluto; quello che conta è l’ordine relativo fra i due valori come vengono osservati da ciascun lato. Nel caso limite in cui i timestamp risultino identici, viene applicato un criterio di spareggio semplice ma stabile, ad esempio un identificatore interno del peer, in modo che anche in quella situazione insolita la scelta del leader sia coerente su entrambi i lati.

Una volta verificata la compatibilità e stabiliti i ruoli, la sincronizzazione vera e propria viene avviata con un allineamento iniziale di tipo “full sync”. Appena entra nello stato sincronizzato, il leader costruisce una fotografia completa dello stato di riproduzione leggendo i dati dal video element locale: include almeno la posizione corrente in secondi, lo stato di riproduzione (in play o in pausa) e, se necessario, altre informazioni come la velocità di riproduzione. La durata complessiva, invece, è già stata scambiata e verificata in fase di attivazione e non è necessario duplicarla in questo messaggio. Il leader invia al follower questo “full state” e il follower, appena lo riceve, esegue un aggancio duro: imposta il proprio player esattamente alla stessa posizione, porta il video nello stesso stato di play o pausa e, se la configurazione lo richiede, forza la velocità di riproduzione a un valore unificato, tipicamente la velocità normale. Durante l’applicazione del full state e di tutti i comandi remoti derivati dal protocollo, il follower marca le modifiche come di sistema, disabilitando temporaneamente la generazione di eventi di sync lato locale, in modo che queste modifiche non vengano scambiate per azioni dell’utente e non producano ulteriori messaggi verso il leader.

Completata la fase di aggancio, il protocollo entra in un regime normale in cui si distinguono i messaggi automatici, o heartbeat, dai messaggi manuali generati dalle azioni degli utenti. In regime normale il compito principale del leader è quello di inviare messaggi automatici a intervalli regolari, intervalli configurabili in un modulo centrale di configurazione. A ogni intervallo, il leader legge nuovamente lo stato del proprio video element, raccoglie la posizione corrente, lo stato di play o pausa e gli altri parametri rilevanti, e invia al follower un messaggio automatico che rappresenta lo stato attuale. Il follower, quando riceve un messaggio di questo tipo, confronta la propria posizione con quella dichiarata dal leader e calcola un drift, cioè la differenza assoluta in secondi tra i due timecode. Se la differenza è inferiore a una soglia di desincronizzazione morbida, configurabile, il follower non interviene; se invece supera una soglia di desincronizzazione dura, anch’essa configurabile, il follower esegue un nuovo hard seek per riallineare la propria posizione a quella del leader, aggiornando allo stesso tempo lo stato di play o pausa secondo le informazioni ricevute. Nella versione base del protocollo implementata nel codice, questa soglia dura è l’unico vero criterio per decidere se applicare un riallineamento automatico; la soglia morbida è presente nei parametri di configurazione come deadband minima e per eventuali estensioni future, ma non introduce logiche di correzione più sofisticate oltre a limitare interventi inutili quando il drift è molto contenuto.

Oltre ai messaggi automatici esistono i messaggi manuali, che rappresentano le vere intenzioni degli utenti. Entrambi i peer possono generarli. Questi messaggi nascono esclusivamente da interazioni esplicite dell’utente con il player: clic sui controlli di play e pausa, salti manuali a un altro punto del video, drag della barra di avanzamento, uso di scorciatoie da tastiera che cambiano posizione o stato di riproduzione. Il content script osserva continuamente il tempo e lo stato del video tramite messaggi periodici provenienti dal contesto della pagina e, quando rileva un cambiamento che non è stato causato da un comando remoto del protocollo e che supera determinate soglie, lo interpreta come azione locale dell’utente. In quel caso costruisce un messaggio manuale che contiene lo stato aggiornato di riproduzione (almeno posizione e play/pause) e lo invia immediatamente all’altro peer. In questa modalità i messaggi manuali hanno priorità assoluta rispetto ai messaggi automatici; non c’è gerarchia fra leader e follower per le azioni manuali, e il sistema adotta implicitamente la regola per cui l’ultimo evento manuale ricevuto vince su ciascun lato, accettando che, in presenza di latenze di rete diverse, per brevi istanti i due client possano avere una sequenza di eventi leggermente diversa prima che heartbeat e ulteriori messaggi riportino i due stati a coincidere.

Per evitare che un heartbeat automatico arrivi subito dopo un’azione manuale locale e sovrascriva uno stato appena concordato, il follower mantiene anche memoria del momento in cui ha generato l’ultima azione manuale locale. Quando l’utente interagisce con il player e il client invia un messaggio manuale, viene registrato un timestamp di quell’azione. Nei secondi successivi, per una finestra temporale configurabile, i messaggi automatici provenienti dal leader vengono ignorati deliberatamente dal follower, a meno che non si tratti di un nuovo manuale o di un full state esplicito. In questo intervallo il follower continua quindi a considerare autorevole lo stato derivato dall’azione manuale, lasciando che siano solo altri manual o, se necessario, un nuovo full state a modificarlo. Anche i riallineamenti effettuati in risposta a messaggi automatici non vengono trattati come input dell’utente e non generano a loro volta nuovi messaggi manuali.

Non tutti gli eventi osservabili sul player vengono considerati ai fini del sync. In particolare, le transizioni di stato dovute a buffering interno di Netflix, a micro-pause automatiche o ad altri meccanismi autonomi della piattaforma non dovrebbero tradursi in messaggi manuali. Il content script che osserva il video cerca di distinguere fra cambiamenti di stato dovuti alla UI e cambiamenti dovuti a condizioni di rete o a comandi remoti, marcando esplicitamente le modifiche applicate per effetto del protocollo e utilizzando soglie di variazione ragionevoli, ma, dato che le API disponibili non espongono un segnale esplicito di buffering, questa distinzione non può essere perfetta in tutti i casi. Allo stesso modo, se la modalità sync prevede una velocità unificata, eventuali cambiamenti di playback rate effettuati dall’utente o dalla piattaforma vengono ignorati o riportati rapidamente al valore standard in occasione dei sync e non sono trattati come vere azioni di sincronizzazione.

La disattivazione del sync è simmetrica e cerca di non disturbare la riproduzione più del necessario. Quando uno dei due utenti disattiva il sync, il suo client entra di nuovo nella fase disattivata, interrompe sia la generazione dei messaggi di sync sia l’elaborazione dei messaggi in arrivo, e invia al peer un messaggio di deattivazione. Il peer remoto, ricevuta questa notifica, esce anch’esso dallo stato sincronizzato, smette di reagire ai messaggi di sync e mantiene la riproduzione nella posizione corrente. Da quel momento in avanti i due player tornano a essere completamente indipendenti. Se uno dei due utenti decide in seguito di riattivare il sync, la procedura ricomincia dall’inizio: scambio delle durate, controllo di compatibilità, scambio dei timestamp di attivazione, elezione del leader, invio del full state da parte del leader e nuovo aggancio del follower.

Per quanto riguarda la stabilità della connessione, la versione attuale del protocollo include un meccanismo di timeout associato agli heartbeat del leader. Mentre i due peer sono nello stato sincronizzato, il follower misura il tempo trascorso dall’ultimo messaggio automatico ricevuto. Se questo intervallo supera un valore configurabile, considera il sync degradato: entra in uno stato dedicato e può segnalare all’utente che la sincronizzazione è in stato non ottimale, sospendendo i riallineamenti automatici basati sugli heartbeat finché i due non disattivano e riattivano la funzione o la connessione non torna stabile. Tutte le durate degli intervalli, le soglie di differenza ammessa, il comportamento del controllo sulla durata, la gestione del playback rate e l’abilitazione dei log di debug sono centralizzati in un modulo di configurazione, che consente di affinare l’esperienza e adattare il protocollo a contesti diversi senza dover modificare la logica di alto livello.
