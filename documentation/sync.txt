Il protocollo di sincronizzazione è progettato per funzionare esclusivamente tra due utenti connessi che stanno guardando lo stesso contenuto su Netflix, nella stessa pagina di riproduzione. Si assume che siano gli utenti a portarsi manualmente sullo stesso film o sulla stessa puntata; il sistema non sceglie né cambia autonomamente il contenuto, ma si limita a verificare che i due media risultino compatibili. Per farlo, ciascun lato legge la durata locale del video dall’elemento video HTML della pagina e, quando entrambi hanno attivato il sync, confronta il proprio valore con quello ricevuto dal peer. Se la differenza relativa tra le due durate supera una soglia configurabile il contenuto viene considerato non compatibile, il protocollo non entra nello stato di sincronizzazione attiva e l’interfaccia può comunicare all’utente che non è possibile sincronizzare le riproduzioni.

Internamente il protocollo distingue quattro fasi di stato: la fase disattivata, in cui il sync è spento e non viene scambiato alcun messaggio di coordinamento; la fase di attivazione, in cui almeno uno dei due utenti ha premuto il pulsante di sync e i due client si stanno scambiando informazioni preliminari; la fase sincronizzata, in cui leader e follower sono agganciati e stanno scambiando heartbeat periodici; e infine la fase degradata, in cui il follower non riceve più heartbeat nei tempi previsti e sospende i riallineamenti automatici. All’inizio, quando un utente preme il pulsante di sync, il suo client passa dalla fase disattivata alla fase di attivazione, registra un timestamp di attivazione e invia al peer un messaggio che contiene questo timestamp insieme alla durata locale del media. Finché solo uno dei due ha attivato il sync, o finché un lato non ha ancora ricevuto i dati dall’altro, entrambi rimangono in questa fase intermedia.

Quando entrambi i lati hanno attivato il sync, hanno scambiato timestamp e durata, e il controllo di compatibilità sulla durata è andato a buon fine, il protocollo procede a eleggere un leader e un follower. L’elezione è deterministica e si basa prima di tutto sui timestamp di attivazione: il peer che ha attivato per primo, cioè quello con timestamp più vecchio, assume il ruolo di leader, mentre l’altro assume il ruolo di follower. Non è necessario che gli orologi dei due sistemi siano sincronizzati in assoluto; quello che conta è l’ordine relativo fra i due valori come vengono osservati da ciascun lato. Nel caso limite in cui i timestamp risultino identici, viene applicato un criterio di spareggio semplice ma stabile, basato su un identificatore interno del peer, in modo che anche in quella situazione insolita la scelta del leader sia coerente su entrambi i lati.

Una volta verificata la compatibilità e stabiliti i ruoli, la sincronizzazione vera e propria viene avviata con un allineamento iniziale di tipo “full sync”. Appena entra nello stato sincronizzato, il leader costruisce una fotografia completa dello stato di riproduzione leggendo i dati dal proprio video element locale (posizione corrente in secondi, stato di riproduzione in play o in pausa, durata e velocità di riproduzione corrente o forzata). La durata complessiva è già stata scambiata e verificata in fase di attivazione, ma viene comunque inclusa nel messaggio come informazione ridondante. Il leader invia al follower questo “full state” e il follower, appena lo riceve, esegue un aggancio duro: imposta il proprio player alla stessa posizione, porta il video nello stesso stato di play o pausa e, se la configurazione lo richiede, forza la velocità di riproduzione a un valore unificato, tipicamente la velocità normale. Durante l’applicazione del full state e di tutti i comandi remoti derivati dal protocollo, il follower marca internamente queste modifiche come non originate dall’utente e disabilita per un breve intervallo la rilevazione delle azioni locali, in modo che tali cambiamenti non vengano scambiati per azioni manuali e non producano ulteriori messaggi verso il leader.

Completata la fase di aggancio, il protocollo entra in un regime normale in cui si distinguono i messaggi automatici, o heartbeat, dai messaggi manuali generati dalle azioni degli utenti. In regime normale il compito principale del leader è quello di inviare messaggi automatici a intervalli regolari, intervalli configurabili in un modulo centrale di configurazione. A ogni intervallo, il leader utilizza lo stato locale del player (posizione, play/pause) mantenuto aggiornato dal bridge verso la pagina e invia al follower un messaggio automatico che rappresenta lo stato attuale. Il follower, quando riceve un messaggio di questo tipo, confronta la propria posizione con quella dichiarata dal leader, compensa la latenza di rete utilizzando il timestamp di invio e calcola un drift, cioè la differenza assoluta in secondi tra i due timecode. Nella versione attuale della logica questo drift viene riportato all’interfaccia ma viene usato per effettuare riallineamenti automatici solo se supera una soglia di desincronizzazione dura configurabile; in tal caso il follower esegue un nuovo hard seek per riallineare la propria posizione a quella del leader, aggiornando allo stesso tempo lo stato di play o pausa secondo le informazioni ricevute. Un parametro di soglia “morbida” esiste nella configurazione come potenziale deadband per evoluzioni future, ma al momento non viene utilizzato dal codice di runtime e non introduce logiche aggiuntive rispetto all’uso della sola soglia dura.

Oltre ai messaggi automatici esistono i messaggi manuali, che rappresentano le vere intenzioni degli utenti. Entrambi i peer possono generarli. Questi messaggi nascono esclusivamente da interazioni esplicite dell’utente con il player: clic sui controlli di play e pausa, salti manuali a un altro punto del video, drag della barra di avanzamento, uso di scorciatoie da tastiera che cambiano posizione o stato di riproduzione. Il content script osserva continuamente il tempo e lo stato del video tramite messaggi periodici provenienti dal contesto della pagina e, quando rileva un cambiamento che non è stato causato da un comando remoto del protocollo, che supera determinate soglie e che non rientra nella breve finestra di soppressione post-aggiornamento remoto, lo interpreta come azione locale dell’utente. In quel caso costruisce un messaggio manuale che contiene lo stato aggiornato di riproduzione (almeno posizione e play/pause) e lo invia immediatamente all’altro peer. In questa modalità i messaggi manuali hanno priorità rispetto agli heartbeat; non c’è gerarchia fra leader e follower per le azioni manuali, e il sistema adotta la regola di fatto per cui l’ultimo evento manuale ricevuto vince su ciascun lato, accettando che, in presenza di latenze di rete diverse, per brevi istanti i due client possano avere una sequenza di eventi leggermente diversa prima che heartbeat e ulteriori messaggi riportino i due stati a coincidere.

Per evitare che un heartbeat automatico arrivi subito dopo un’azione manuale locale e sovrascriva uno stato appena concordato, il follower mantiene anche memoria del momento in cui ha generato l’ultima azione manuale locale. Quando l’utente interagisce con il player e il client invia un messaggio manuale, viene registrato un timestamp di quell’azione. Nei secondi successivi, per una finestra temporale configurabile, i messaggi automatici provenienti dal leader vengono ignorati deliberatamente dal follower, mentre i messaggi manuali e i full state espliciti continuano a essere applicati normalmente. In questo intervallo il follower continua quindi a considerare autorevole lo stato derivato dall’azione manuale, lasciando che siano solo altri manual o, se necessario, un nuovo full state a modificarlo. Anche i riallineamenti effettuati in risposta a messaggi automatici non vengono trattati come input dell’utente e non generano a loro volta nuovi messaggi manuali.

Non tutti gli eventi osservabili sul player vengono considerati ai fini del sync. In particolare, le transizioni di stato dovute a buffering interno di Netflix, a micro-pause automatiche o ad altri meccanismi autonomi della piattaforma non dovrebbero tradursi in messaggi manuali. Il content script che osserva il video cerca di distinguere fra cambiamenti di stato dovuti alla UI e cambiamenti dovuti a condizioni di rete o a comandi remoti, marcando esplicitamente le modifiche applicate per effetto del protocollo e utilizzando soglie di variazione ragionevoli, ma, dato che le API disponibili non espongono un segnale esplicito di buffering, questa distinzione non può essere perfetta in tutti i casi. Allo stesso modo, se la modalità sync prevede una velocità unificata, eventuali cambiamenti di playback rate effettuati dall’utente o dalla piattaforma vengono ignorati o riportati rapidamente al valore standard in occasione dei sync e non sono trattati come vere azioni di sincronizzazione.

La disattivazione del sync è simmetrica e cerca di non disturbare la riproduzione più del necessario. Quando uno dei due utenti disattiva il sync, il suo client entra di nuovo nella fase disattivata, interrompe la generazione dei messaggi di sync, smette di reagire agli aggiornamenti automatici e invia al peer un messaggio di deattivazione. Il peer remoto, ricevuta questa notifica, esce anch’esso dallo stato sincronizzato, aggiorna il proprio stato interno a “sync disattivato”, smette di considerare validi i messaggi di sync e mantiene la riproduzione nella posizione corrente. Da quel momento in avanti i due player tornano a essere completamente indipendenti. Se uno dei due utenti decide in seguito di riattivare il sync, la procedura ricomincia dall’inizio: scambio delle durate, controllo di compatibilità, scambio dei timestamp di attivazione, elezione del leader, invio del full state da parte del leader e nuovo aggancio del follower.

Per quanto riguarda la stabilità della connessione, la versione attuale del protocollo include un meccanismo di timeout associato agli heartbeat del leader. Mentre i due peer sono nello stato sincronizzato, il follower misura il tempo trascorso dall’ultimo messaggio automatico ricevuto. Se questo intervallo supera un valore configurabile, considera il sync degradato: entra in uno stato dedicato e può segnalare all’utente che la sincronizzazione è in stato non ottimale, sospendendo i riallineamenti automatici basati sugli heartbeat. Lo stato degradato non viene recuperato automaticamente al ritorno degli heartbeat: per tornare in una situazione pienamente sincronizzata è necessario che gli utenti disattivino e riattivino il sync, facendo ripartire la procedura di handshake dall’inizio. Tutte le durate degli intervalli, le soglie di differenza ammessa, il comportamento del controllo sulla durata, la gestione del playback rate e l’abilitazione dei log di debug sono centralizzati in un modulo di configurazione, che consente di affinare l’esperienza e adattare il protocollo a contesti diversi senza dover modificare la logica di alto livello.
