Il protocollo di sync è progettato per funzionare esclusivamente tra due utenti connessi, che stanno guardando lo stesso contenuto su Netflix nella stessa pagina. Si assume che siano stati gli utenti stessi a mettersi sulla stessa serie o sullo stesso film; il protocollo esegue solo un controllo di coerenza sulla durata: ciascun lato legge la durata del media locale e, quando entrambi hanno attivato il sync, confronta la propria durata con quella dichiarata dall’altro. Se la differenza relativa supera una soglia configurabile (ad esempio l’1%), il sync non viene attivato perché il sistema considera i contenuti non compatibili; in questo caso nessuno dei due entra nello stato “synced” e l’interfaccia può segnalare semplicemente che non è possibile sincronizzare le riproduzioni.

L’attivazione del sync è locale e poi coordinata. Quando un utente preme il tasto Sync, il suo client registra un timestamp di attivazione e lo comunica all’altro peer insieme alla durata del media. Il sync rimane in stato “parzialmente attivo” finché solo uno dei due ha abilitato la funzione; solo quando anche il secondo utente abilita il sync e entrambi hanno scambiato i rispettivi timestamp e durata, il protocollo verifica prima il vincolo sulle durate e, se superato, procede a eleggere leader e follower. L’elezione del leader è deterministica e basata sui timestamp di attivazione scambiati: il peer che ha attivato il sync per primo, cioè quello con timestamp di attivazione più vecchio, si considera leader, l’altro si considera follower. Non serve che gli orologi dei due sistemi siano sincronizzati in assoluto, perché conta solo l’ordine relativo fra i due valori che ciascun lato vede. Nel caso limite in cui i timestamp risultassero identici, può essere adottato un criterio di tie-break banale ma stabile (per esempio un identificatore interno del peer), ma questa è una condizione abbastanza rara da poter rimanere un dettaglio di implementazione.

Una volta stabilito che il contenuto è compatibile e che c’è un leader, la sincronizzazione vera e propria viene avviata con un allineamento iniziale. Il leader, appena entra nello stato synced, invia al follower uno stato completo della riproduzione che comprende almeno la posizione corrente del media, lo stato play/pause e la durata. In questa fase si può anche decidere esplicitamente che la velocità di riproduzione supportata in modalità sync è solo quella normale, forzando eventuali playback rate diversi a 1.0. Il follower, quando riceve questo messaggio di “full state”, applica un hard sync: imposta il proprio player esattamente alla stessa posizione, allo stesso stato di play o pausa e, se necessario, alla stessa velocità. Per evitare loop e falsi trigger, durante l’applicazione di questo comando remoto il follower disabilita temporaneamente la generazione di eventi di sync dovuti ai listener locali; in pratica marca queste modifiche come “di sistema”, così non vengono interpretate come azioni dell’utente e non generano nuovi messaggi verso il leader.

Una volta completata la fase di aggancio, il protocollo entra nel regime normale e distingue nettamente tra messaggi automatici e messaggi manuali. Il ruolo del leader, in questa fase, è limitato alla gestione dei messaggi automatici periodici. A intervalli regolari, configurabili in syncConfig.ts (per esempio ogni cinque secondi), il leader legge lo stato del proprio player, raccoglie posizione, stato di riproduzione e gli altri parametri rilevanti, e invia al follower un messaggio automatico che rappresenta una fotografia dello stato corrente. Il follower, quando riceve un messaggio di questo tipo, decide se e come reagire in base a soglie configurabili: se la differenza fra la propria posizione e quella del leader è molto piccola e inferiore a una soglia morbida, non fa nulla; se supera una soglia più alta, trattata come soglia di desync “duro”, esegue un hard seek e si allinea al leader sia come timecode, sia come stato di play o pausa, di nuovo segnando queste modifiche come remote per non scatenare eventi di sync aggiuntivi. Tra la soglia soft e quella hard si può scegliere di non intervenire oppure, nelle versioni future, implementare correzioni più graduali, ma nella versione base del protocollo è sufficiente usare la soglia hard come unico discriminante per il riallineamento.

Indipendentemente dalla leadership, entrambe le parti possono generare messaggi manuali. Questi messaggi nascono esclusivamente da vere interazioni dell’utente con il player: clic sul pulsante play/pause, modifiche del minutaggio, drag della barra di avanzamento, eventuali scorciatoie da tastiera supportate da Netflix. Ogni volta che un client rileva una di queste azioni mentre il sync è attivo, tratta quell’azione come la nuova intenzione “autorevole” dell’utente locale e invia immediatamente all’altro peer un messaggio manuale che contiene lo stato aggiornato della riproduzione. In questo scenario non esiste gerarchia: un manual trigger ha la stessa importanza, sia che provenga dal leader sia che provenga dal follower, e ogni client che lo riceve lo applica sempre e comunque con priorità massima rispetto a quanto stabilito dai messaggi automatici. Questo significa che il protocollo implicitamente adotta la regola “l’ultimo evento manuale ricevuto vince” su ciascun lato, accettando che in presenza di ritardi di rete molto diversi i due client possano vedere la sequenza degli eventi in ordine leggermente diverso per qualche istante, prima che i successivi messaggi e gli heartbeat automatici riportino i due stati a coincidere.

Per evitare conflitti fra heartbeat e azioni dell’utente, il follower mantiene anche una memoria del momento dell’ultima azione locale che ha generato un messaggio manuale. Quando l’utente interagisce con il player locale e viene inviato il relativo messaggio di sync, il client registra un timestamp di quest’azione. Nei successivi secondi, per una finestra temporale configurabile, i messaggi automatici provenienti dal leader vengono deliberatamente ignorati dal follower, a meno che non si tratti di messaggi manuali o di full state. Questo meccanismo serve a evitare che un heartbeat con informazioni leggermente datate, spedito dal leader quasi in contemporanea con l’azione manuale del follower, arrivi subito dopo e sovrascriva lo stato appena concordato dai due peer tramite il messaggio manuale. Anche in questo caso le modifiche derivate da messaggi automatici non vengono interpretate come interazioni dell’utente, e non producono a loro volta nuovi trigger manuali.

Alcuni eventi del player non vengono considerati ai fini del sync. Le transizioni di stato dovute a buffering interno di Netflix, o altri meccanismi autonomi della piattaforma, non devono generare messaggi manuali; il content script che osserva il player deve distinguere fra cambiamenti di stato dovuti alla UI e cambiamenti dovuti a condizioni di rete o a messaggi remoti. Allo stesso modo, se la modalità sync richiede una velocità unificata, eventuali cambiamenti di playback rate vanno ignorati o immediatamente riportati al valore standard in occasione dei sync, e non devono essere trattati come vere azioni di sincronizzazione.

La disattivazione del sync è simmetrica e spegne la logica di coordinamento senza alterare più del necessario la riproduzione. Se uno dei due utenti disattiva il sync, il suo client invia un messaggio di deactivazione all’altro peer e smette sia di generare messaggi, sia di reagire a quelli di sync in arrivo. Il peer remoto, ricevuta la notifica, esce anch’esso dallo stato synced e torna a comportarsi come se il protocollo non fosse attivo, lasciando la riproduzione nella posizione corrente. Da quel momento in poi, la riproduzione dei due utenti torna completamente indipendente. Se uno dei due utenti riattiva in seguito il sync, parte una nuova negoziazione identica alla prima: scambio delle durate, controllo di compatibilità, scambio dei timestamp di attivazione, elezione del leader, invio del full state dal leader al follower e nuovo aggancio.

Per quanto riguarda la stabilità della connessione, il protocollo nella sua versione iniziale assume che non vi siano crash del browser o disconnessioni prolungate. Tuttavia, per maggiore robustezza, è possibile associare agli heartbeat del leader un timeout configurabile: se il follower non riceve messaggi automatici dal leader per un certo intervallo di tempo mentre si trova nello stato synced, può segnalare all’utente che il sync è in stato degradato e sospendere i riallineamenti automatici finché i due non riattivano la funzione. Tutti gli intervalli temporali, le soglie di differenza ammessa, il comportamento del controllo sulla durata e l’eventuale logging di debug sono parametrizzati in un modulo di configurazione centralizzato, che permette di affinare l’esperienza senza modificare la logica di alto livello del protocollo.
